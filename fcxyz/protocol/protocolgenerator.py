import json
import datetime
import os
from protocolparser import ProtocolParser
from protocolelements import Action, CommandPair, Variable, SectionLabel
import pathlib
from dataclasses import dataclass

# load a text file from the local directory
# get the current working directory
# protocol_path = "./protocolgen/resources/sample_protocols/test_protocol_light.p"

# pp = ProtocolParser(protocol_path)

# protocol = ProtocolParser(protocol_path)

# protocol.parse_script()


class ProtocolParameters:
    def __init__(
        self,
        name: str = None,
        actions: list = None,
        variables: list = None,
        command_pairs: list = None,
    ):
        self.name = name
        self.actions = []
        self.variables = []
        self.command_pairs = []
        self.delimiter = "\n"
        self.section_delimeter = f";{'*'*25}\n"

    def serialize(self):
        return (
            self.delimiter.join(self.get_action_strings())
            + self.delimiter.join(self.get_variable_strings())
            + self.delimiter.join(self.get_command_pair_strings())
        )

    def get_action_strings(self):
        return [action.stringify() for action in self.actions]

    def get_variable_strings(self):
        return [variable.stringify() for variable in self.variables]

    def get_command_pair_strings(self):
        return [command_pair.stringify() for command_pair in self.command_pairs]


#   <-mfmsub_length>=>mfmsub ;before pulse
#   <0s>=>SatPulse(800ms)
#   <TS,TS + 2 * mfmsub_length .. 800ms/2 - mfmsub_length>=>mfmsub
#   <800ms/2,800ms/2 + mfmsub_length .. 800ms>=>mfmsub
#   <800ms + mfmsub_length>=>mfmsub
# end"
# {action.definitions} {action.commands}"


class ProtocolGenerator:
    """class for generating a new protocol from a template protocol"""

    def __init__(
        self,
        protocol_name: str,
        protocol_version: str,
        protocol_author: str,
        protocol_date: str,
    ):
        self.protocol_name = protocol_name
        self.protocol_version = protocol_version
        self.protocol_author = protocol_author
        self.protocol_date = protocol_date

    def create_protocol(self, protocol_parameters: ProtocolParameters) -> str:
        """generates a new protocol from a protocol parameters object"""
        self.protocol_parameters = protocol_parameters
        return self.serialize_protocol()

    def serialize_protocol(self) -> str:
        """generates a new serialized protocol from a protocol parameters object"""
        return (
            f";Generated by {self.protocol_author} on {self.protocol_date}\n"
            + "include default.inc;\ninclude light.inc \n;"
            + self.protocol_parameters.serialize_variables()
            + self.protocol_parameters.serialize_actions()
            + self.protocol_parameters.serialize_commands()
        )


@dataclass
class LightValue:
    blue: int
    red: int

    @property
    def act1(self):
        return self.red

    @property
    def act2(self):
        return self.blue


@dataclass
class TimeValue:
    value: float
    unit: str

    @property
    def time(self):
        return self._calulate_time()

    @property
    def time_string(self):
        return f"{self.value}{self.unit}"

    def _calulate_time(self):
        if self.unit == "m":
            return self.value * 60.0
        elif self.unit == "s":
            return self.value
        elif self.unit == "ms":
            return self.value / 1000.0
        else:
            raise ValueError(f"Invalid time unit {self.unit}")


@dataclass
class LightProtocol:
    name: str
    description: str
    protocol_blocks: list
    section_delimeter: str = f";{'*'*25}\n"
    time_step: TimeValue = TimeValue(20, "ms")
    pulse_duration = TimeValue(800, "ms")
    light_value = LightValue(70, 60)
    protocol_type: str = "light"

    def include_header(self):
        return "\n".join(
            [
                f";------------------------------------------------",
                f";protocol: {self.name}",
                f";notes: {self.description}" f";created: {datetime.datetime.now()}",
                f";------------------------------------------------",
                "TS=20ms",
                "Shutter=3",
                "Sensitivity=52",
                "Act1={}",
                "Super=100",
                "include default.inc;",
                "include light.inc;",
            ]
        )

    def include_actions(self) -> str:
        """returns a string of the actions to be included in the protocol"""
        time_step = self.time_step.time_string

        return "\n".join(
            [
                ";------------------------------------------------",
                ";-----------------  Actions --------------------",
                ";------------------------------------------------",
                "Action SATPULSE(end_time) begin",
                "<-mfmsub_length>=>mfmsub",
                f"<0s>=>act1({self.pulse_duration.time_string})",
                f"<0s>=>act2({self.pulse_duration.time_string})",
                "<0s,TS + 2 * mfmsub_length .. end_time>=>mfmsub",
                "<end_time + mfmsub_length>=>mfmsub",
                "end",
                "Action FARRED_MEASURE(end_time) begin",
                f"<0s, {time_step}, .. end_time - mfmsub_length>=>FAR({time_step} - 2*mfmsub_length)",
                f"<{time_step} - 2*mfmsub_length, {time_step}, .. end_time - mfmsub_length>=>mfmsub",
                "end",
                "Action MEASURE(end_time) begin",
                f"<{time_step} - 2*mfmsub_length, {time_step}, .. end_time - mfmsub_length>=>mfmsub",
                "end",
                "\n",
                ";------------------------------------------------",
                ";--------------  Start Protocol -----------------",
                ";------------------------------------------------",
                "\n",
            ]
        )

    def serialize(self):
        protocol_time = 0.0
        block_string_list = []

        for block in self.protocol_blocks:
            block_string, protocol_time = block.serialize(protocol_time)
            block_string_list.append(block_string)

        return (
            self.include_header()
            + self.include_actions()
            + "\n".join(block_string_list)
        )


@dataclass
class ProtocolBlock:
    name: str
    type: str
    period: TimeValue
    light: LightValue
    pulses: int
    far_red: bool
    check_points: list = None
    pulse_duration: TimeValue = TimeValue(0.8, "s")

    def serialize(self, protocol_time: float):
        """returns a string representation of the protocol block"""
        time_before_pulse, final_time = 0.0, 0.0

        if self.pulses > 0:
            time_before_pulse = self.period.time / self.pulses
            final_time = protocol_time + self.pulses * (
                time_before_pulse + self.pulse_duration.time
            )
        else:
            time_before_pulse = self.period.time
            final_time = protocol_time + self.period.time

        block_string = "".join(
            [
                self._get_pulse_string(
                    protocol_time=protocol_time,
                    time_before_pulse=time_before_pulse,
                    i=i,
                )
                for i in range(0, self.pulses)
            ]
        )

        return block_string, final_time

    def _get_pulse_string(
        self,
        protocol_time: float = 0.0,
        time_before_pulse: float = 0.0,
        i: int = 0,
    ) -> str:
        """returns a string representation of a pulse in the protocol block"""
        start_time = round(
            protocol_time + i * (time_before_pulse + self.pulse_duration.time), 3
        )
        end_time = round(start_time + self.pulse_duration.time, 3)
        string_list = []

        if self.light.red > 0:
            string_list.append(f"<{start_time}s>=>act1({time_before_pulse}s);\n")
        if self.light.blue > 0:
            string_list.append(f"<{start_time}s>=>act2({time_before_pulse}s);\n")
        if self.far_red:
            string_list.append(f"FARRED_MEASURE({time_before_pulse})\n")
        else:
            string_list.append(f"<{start_time}s>=>MEASURE({time_before_pulse}s);\n")

        if self.pulses > 0:
            string_list.append(
                f"<{start_time + self.pulse_duration.time}s>=>SATPULSE({self.pulse_duration.time}s);\n"
            )

        if self.check_points is not None:
            for check_point in self.check_points:
                string_list.append(
                    self.get_check_point_string(check_point, start_time, end_time, i)
                )
        return "".join(string_list)

    def get_check_point_string(self, check_point, start_time, end_time, i):
        out_list = []
        if "ss" in check_point:
            i_num = "ss"
        else:
            i_num = i + 1

        # if any(substring in  for strin check_point):
        if self.string_contains(check_point, ["Fo", "Fs", "Ft"]):
            start_point = end_time - (0.5 * self.pulse_duration.time)
            end_point = end_time
        if "Fm" in check_point:
            start_point = end_time - self.pulse_duration.time
            end_point = end_time

        out_list.append(
            f'<{start_point}s - 2*TS>=>check_point,"start{check_point}{i_num}";'
        )
        out_list.append(f'<{end_point}s>=>check_point,"end{check_point}{i_num}";')
        return "\n".join(out_list) + "\n"

    def string_contains(self, string, substrings):
        for substring in substrings:
            if substring in string:
                return True
        return False


if __name__ == "__main__":
    test_protocol = LightProtocol(
        name="test_protocol",
        description="test protocol",
        protocol_blocks=[
            ProtocolBlock(
                name="pre_fm_pulse",
                type="l, ss",
                period=TimeValue(10, "s"),
                light=LightValue(70, 70),
                pulses=0,
                far_red=False,
                pulse_duration=TimeValue(0.0, "s"),
                check_points=[],
            ),
            ProtocolBlock(
                name="fm_pulse",
                type="m, ss",
                period=TimeValue(10, "s"),
                light=LightValue(70, 70),
                pulses=1,
                far_red=False,
                pulse_duration=TimeValue(0.8, "s"),
                check_points=["Fo_Lss", "Fm_Lss"],
            ),
            ProtocolBlock(
                name="foprime",
                type="d",
                period=TimeValue(5, "s"),
                light=LightValue(0, 0),
                pulses=0,
                far_red=True,
                check_points=[
                    "Foprime",
                ],
            ),
            ProtocolBlock(
                name="recovery",
                type="d",
                period=TimeValue(5, "m"),
                light=LightValue(0, 0),
                pulses=4,
                far_red=False,
                check_points=["Ft_D", "Fm_D"],
            ),
        ],
    )

    protocol_string = test_protocol.serialize()

    with open("test_protocol.txt", "w") as f:
        f.write(protocol_string)
